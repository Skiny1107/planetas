<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amor Espacial 3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }

        #container {
            width: 100%;
            height: 100vh;
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff69b4;
            font-size: 16px;
            text-align: center;
            z-index: 1000;
            text-shadow: 0 0 10px #ff69b4;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div class="instructions">
        ✨ Arrastra para rotar • Scroll para acercar/alejar ✨
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, planet, moon;
        let floatingObjects = [];
        let mouse = { x: 0, y: 0 };
        let targetRotation = { x: 0, y: 0 };
        let currentRotation = { x: 0, y: 0 };

        const phrases = [
            'Te amo ❤️',
            'Mi reina 👑',
            'Para ti 💝',
            'Me encantas 💕',
            'Una diosa ✨',
            'Amor de mi vida 💗',
            'Mi amor 💖',
            'Mi princesa 👸',
            'Te amo tanto 💘',
            'Eres preciosa 🌹',
            'Mi vida 💓',
            'Todo mi amor 💞'
        ];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 1);
            document.getElementById('container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff69b4, 2, 50);
            pointLight1.position.set(10, 10, 10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xff1493, 1.5, 50);
            pointLight2.position.set(-10, -10, 10);
            scene.add(pointLight2);

            // Create stars
            createStars();

            // Create main planet
            createPlanet();

            // Create moon
            createMoon();

            // Create floating elements
            createFloatingElements();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onWheel);

            animate();
        }

        function createStars() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });

            const starsVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 100;
                const y = (Math.random() - 0.5) * 100;
                const z = (Math.random() - 0.5) * 100;
                starsVertices.push(x, y, z);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        function createPlanet() {
            const geometry = new THREE.SphereGeometry(3, 64, 64);
            
            // Create a beautiful gradient texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#ff69b4');
            gradient.addColorStop(0.5, '#ff1493');
            gradient.addColorStop(1, '#ffc0cb');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add some texture patterns
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 30 + 10;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 100,
                specular: 0xff69b4,
                emissive: 0xff1493,
                emissiveIntensity: 0.2
            });

            planet = new THREE.Mesh(geometry, material);
            scene.add(planet);

            // Add glow effect
            const glowGeometry = new THREE.SphereGeometry(3.3, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff69b4,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            planet.add(glow);
        }

        function createMoon() {
            const geometry = new THREE.SphereGeometry(0.8, 32, 32);
            
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');
            
            const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.5, '#e0e0e0');
            gradient.addColorStop(1, '#c0c0c0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);
            
            // Add craters
            ctx.fillStyle = 'rgba(150, 150, 150, 0.3)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 256;
                const y = Math.random() * 256;
                const radius = Math.random() * 15 + 5;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 50
            });

            moon = new THREE.Mesh(geometry, material);
            moon.position.set(8, 3, 2);
            scene.add(moon);
        }

        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;

            ctx.fillStyle = 'rgba(255, 105, 180, 0.9)';
            ctx.font = 'bold 48px Georgia';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = '#ff1493';
            ctx.shadowBlur = 20;
            ctx.fillText(text, 256, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(4, 1, 1);

            return sprite;
        }

        function createImageCard() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, 256, 256);
            gradient.addColorStop(0, '#ff69b4');
            gradient.addColorStop(1, '#ff1493');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 256);

            // Add heart
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 120px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('💕', 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });

            return new THREE.Mesh(geometry, material);
        }

        function createFloatingElements() {
            const orbitRadius = 7;
            
            phrases.forEach((phrase, index) => {
                const angle = (index / phrases.length) * Math.PI * 2;
                const element = Math.random() > 0.5 ? createTextSprite(phrase) : createImageCard();
                
                const x = Math.cos(angle) * orbitRadius;
                const y = (Math.random() - 0.5) * 6;
                const z = Math.sin(angle) * orbitRadius;
                
                element.position.set(x, y, z);
                
                floatingObjects.push({
                    mesh: element,
                    angle: angle,
                    radius: orbitRadius,
                    speed: 0.0005 + Math.random() * 0.001,
                    verticalSpeed: 0.001 + Math.random() * 0.002,
                    verticalOffset: Math.random() * Math.PI * 2
                });
                
                scene.add(element);
            });
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            targetRotation.x = mouse.y * 0.5;
            targetRotation.y = mouse.x * 0.5;
        }

        function onWheel(event) {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(8, Math.min(25, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Smooth rotation
            currentRotation.x += (targetRotation.x - currentRotation.x) * 0.05;
            currentRotation.y += (targetRotation.y - currentRotation.y) * 0.05;

            // Rotate planet
            planet.rotation.y += 0.002;
            planet.rotation.x = currentRotation.x * 0.3;

            // Rotate moon around planet
            const time = Date.now() * 0.0005;
            moon.position.x = Math.cos(time) * 8;
            moon.position.z = Math.sin(time) * 8;
            moon.rotation.y += 0.005;

            // Animate floating objects
            floatingObjects.forEach((obj, index) => {
                obj.angle += obj.speed;
                obj.verticalOffset += obj.verticalSpeed;
                
                obj.mesh.position.x = Math.cos(obj.angle + currentRotation.y) * obj.radius;
                obj.mesh.position.z = Math.sin(obj.angle + currentRotation.y) * obj.radius;
                obj.mesh.position.y = Math.sin(obj.verticalOffset) * 2;
                
                // Make elements look at camera
                obj.mesh.lookAt(camera.position);
            });

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>